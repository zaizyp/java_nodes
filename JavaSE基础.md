## JavaSE基础
### 一、面向对象
#### 1、面向对象的特性
1)、继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。  
2)、封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。  
3)、多态性：多态性指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态性是面向对象最精髓的东西，要实现多态需要做两件事：1、方法重写（子类继承父类并重写父类中已有的或者抽象的方法）；2、对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。
4)、抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。
#### 2、访问修饰符
|修饰符|当前类|同包|子类|不同包|
|-----|-----|----|----|-----|
|public| ✔ | ✔  | ✔ |  ✔  |
|protected|✔| ✔ | ✔ |  ✖  |
|default|✔ | ✔  | ✖ |  ✖  |
|private|✔ | ✖  | ✖ |  ✖  |
#### 3、clone对象
##### 3.1、为什么要用clone？
　　在实际编程过程中，我们常常要遇到这种情况：有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能会需要一个和A完全相同的新对象B，并且此后对B任何改动都不会影响带A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在Java语言中，用简单的赋值语句是不能满足这种需求的，要满足这种需求有很多种途径，但实现clone()方法时其中最简单，也是最高效的手段。
##### 3.2、new一个对象的过程和clone一个对象的过程的区别
　　new操作符的本意是分配内存。程序执行到new操作符时，首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。  
　　clone在第一步是和new相似，都是分配内存，调用clone方法时，分配的内存和原对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。
### JavaSE语法
#### 1、Java有没有goto语句？
　　goto是Java中的保留关键字，在目前版本的Java中没有使用。根据James Gosling（Java之父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有共同和const，但这两个是目前无法使用的关键字，因此有些地方将其称为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字。
#### 2、&和&&的区别
　　&运算符有两种用法：（1）按位与；（2）逻辑与。  
　　&&运算符是短路运算符，逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。  
　　&&之所以被称为短路与是因为，如果&&左边的表达式的值时false，幼斌的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名是不是null而且不是空字符串，应该写为`username != null && !username.equals("")`，二者的位置不能交换，更不能使用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。
#### 3、两个对象值相同（`x.equals(y) == true`），但却可以有不同的hashCode，这句话对不对？
　　不对，如果两个对象x和y满足`x.equals(y) == true`，它们的hashCode应当相同。  
　　java对于equals方法和hashCode方法是这样规定的：（1）如果两个对象相同（equals方法返回true），那么他们的hashCode值一定要相同；（2）如果两个对象的hashCode相同，它们不一定相同。当然，你未必要按照要求去做。
#### 4、重载（overload）和重写（override）的区别？重载的方法能否根据返回类型进行区分？
　　方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同，参数个数不同或者二者都不同）则视为重载；重写发生在子类和父类之间，重写要求子类被重写方法与父类之间有相同的方法名、以及参数，而且子类重写方法的返回值类型必须为父类方法返回值类型的派生类。  
　　方法重载的规则：  
　　　　1、方法名一致，参数类表中参数的顺序、类型、个数不同。  
　　　　2、重载与方法的返回值无关，存在于父类和子类、同类中。  
　　　　3、可以抛出不同的异常，可以有不同的修饰符。  
　　方法重写的规则：  
　　　　1、参数列表必须完全与被重写方法的一致，返回类型一致或为被重写方法返回值类型的子类。  
　　　　2、构造方法不能重写，声明为final的方法不能被重写，声明为static的方法不能被重写，但是能够被再次声明。  
　　　　3、访问权限不能比父类中被重写方法的访问权更低。  
　　　　4、重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法时否抛出异常。但是重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
#### 5、char型变量中能不能存储一个中文汉字，为什么？
　　　　char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符集中的编号，这是统一的唯一方法），一个char类型占用2个字节（16比特），所以放一个中文是没问题的。  
**补充:**使用Unicode意味着字符在JVM内部和外部有着不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字节流和字符流之间进行转换的转换流，如InputStreamReader和OutStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。
#### 6、抽象类（abstract class）和接口（interface）有什么异同？
不同：
　　抽象类：
　　　　1、抽象类中可以定义构造器  
　　　　2、可以有抽象方法和具体方法  
　　　　3、接口中的成员全都是public的  
　　　　4、抽象类中可以定义成员变量  
　　　　5、有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法  
　　　　6、抽象类中可以包含静态方法  
　　　　7、一个类只能继承一个抽象类  
　　接口：  
　　　　1、接口中不能定义构造器  
　　　　2、方法全部都是抽象方法  
　　　　3、抽象类中的成员可以是private、默认、protected、public  
　　　　4、接口中定义的成员变量只能是常量（即为final static修饰），且默认为常量  
　　　　5、接口中不能有静态方法  
　　　　6、一个类可以实现多个接口  
　　相同：  
　　　　1、不能够实例化  
　　　　2、可以将抽象类和接口类型作为引用类型  
　　　　3、一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽查方法全部进行实现，否则该类仍需要被声明为抽象类或者接口。
#### 7、静态变量和实例变量的区别？
**静态变量：**是被static修饰符修饰的变量，也称为类变量，它属于类，不属于任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝。
**实例变量：**必须依赖于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共存。
#### 8、==和equals的区别？
equals和==最大的区别是一个是方法一个是运算符。  
==：如果比较的是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。
equals()：用来比较两个对象的内容是否相等。  
注意：equals方法不能用于基础数据类型的变量，如果没有对equals方法进行重写，则比较的是引用类型的变量所指的对象的地址。
#### 9、`String s = "Hello";s = s + "world!";`这两行代码执行后，原始的String对象中的内容到底变了没有？
没有，因为String被设计成不可变类，所以它的所有对象都是不可变对象。String底层实际上是一个final修饰的字符串数组。
